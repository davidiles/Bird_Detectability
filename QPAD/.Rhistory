Nsim = nrow(sim_birds),
sim_dist = sim_birds$dist,
# Distance that each simulated bird belongs to
r_from = r_from,
r_to = r_to,
# To vectorize
n_bins_vectorized = length(Y_rint_numeric),
Y_rint_numeric = Y_rint_numeric,
Y_tint_numeric = Y_tint_numeric
)
# Run once to generate initial values that work
out_inits <- jags(data = init_data,
model.file =  "QPAD_init_vectorized.jags",
parameters.to.save = c("Dsim_matrix","Ysim_matrix","dummy"),
inits = NULL,
n.chains = 3,
n.thin = 1,
n.iter = 2,
n.burnin = 1,
codaOnly=c("Dsim_matrix"))
Dsim = out_inits$sims.list$Dsim_matrix[1,,]
Dsim
Ysim = out_inits$sims.list$Ysim_matrix[1,,]
Ysim
# ******************************************
# ******************************************
# PART 4: WITH INITIAL VALUES CHOSEN, FIT MODEL TO ACTUAL DATA
# ******************************************
# ******************************************
jags_data <- list(
pi = pi,
N_det = sum(Y),
Y_vectorized = Y_vectorized,
# Time bin information
tint = tint,
ntint = length(tint),
tint_duration = diff(c(0,tint)),
# Distance bin information
nrint = length(rint),
# Data augmentation
Nsim = nrow(sim_birds),
sim_dist = sim_birds$dist,
# Distance that each simulated bird belongs to
r_from = r_from,
r_to = r_to,
# To vectorize
n_bins_vectorized = length(Y_rint_numeric),
Y_rint_numeric = Y_rint_numeric,
Y_tint_numeric = Y_tint_numeric
)
# Fit model
inits <- function()list(dc = out_inits$sims.list$dc[1,,],
phi = phi_init,
tau = tau_init)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Density"),
inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
Y_vectorized
phi
phi_init
phi_true
# Fit model
inits <- function()list(phi = phi_true,
tau = tau_true)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Density"),
inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
library(bSims)
library(ggpubr)
library(tidyverse)
library(detect)
library(jagsUI)
library(reshape2)
setwd("~/1_Work/Bird_Detectability/QPAD")
# ----------------------------------------
# Script to fit model
# ----------------------------------------
sink("QPAD_corrected_vectorized.jags")
cat("
model {
# ------------------------------
# Priors
# ------------------------------
phi ~ dunif(0,2)
tau ~ dunif(0,3)
# ------------------------------
# Simulation
# ------------------------------
# For each simulated bird, probability it has generated at least one detectable cue by end of time interval
for (i in 1:Nsim){
# Simulate cueing for each bird in each time interval
for (j in 1:ntint){
# Expected number of cues produced up to end of interval
lambda[i,j] <- phi*tint[j]*exp(-(sim_dist[i]/tau)^2)
# Probability bird produces at least one detectable cue by end of interval
p[i,j] <- 1 - exp(-lambda[i,j])
}
}
# Sum up number of detected birds in each time and distance bin (this is sort of equivalent to the CDF)
for (i in 1:nrint){
for (j in 1:ntint){
Dsim_matrix[i,j] <- sum(p[r_from[i]:r_to[i],j])
}
}
# Difference to calculate cell probabilities
for (i in 1:nrint){
Ysim_matrix[i,1] <- Dsim_matrix[i,1]
for (j in 2:ntint){
Ysim_matrix[i,j] <- Dsim_matrix[i,j] - sum(Dsim_matrix[i,(j-1)])
}
}
# Place counts in correct vectorized bins
for (i in 1:n_bins_vectorized){
Ysim_vectorized[i] <- Ysim_matrix[Y_rint_numeric[i],Y_tint_numeric[i]]
}
# -----------------------------------------------------
# Use relative proportions for detectability modeling
# -----------------------------------------------------
#Y_vectorized[1:n_bins_vectorized] ~ dmulti(Ysim_vectorized[],N_det)
}
",fill = TRUE)
sink()
rm(list=ls())
results_df = data.frame()
#for (sim_rep in 1:100){
#  for (tau_true in c(0.5,1.5)){
#    for (phi_true in c(0.2,0.4)){
N = 100000 # Number of birds to place on landscape (determines overall sample size in point count dataset)
dim = 10 # landscape size (dim x dim landscape)
Density_true = N/dim^2
tau_true <- 0.7
phi_true <- 0.5
# ------------------------------------
# PART 1: GENERATE 'ACTUAL' DATA
# ------------------------------------
birds <- data.frame(bird_id = 1:N,
x = runif(N,-dim/2,dim/2),
y = runif(N,-dim/2,dim/2))
# Distances to observer
birds$dist <- sqrt(birds$x^2 + birds$y^2)
# Simulate bird cues, based on phi_true
cues <- matrix(NA, nrow=N, ncol = 10)
for (bird_id in 1:N) cues[bird_id,] <- cumsum(rexp(ncol(cues),phi_true))
cues <- cues %>%
reshape2::melt() %>%
rename(bird_id = Var1, cue_number = Var2, time = value) %>%
arrange(bird_id,cue_number)
cues$dist <- birds$dist[cues$bird_id]
# Determine which cues are detected, based on tau_true
cues$p<- exp(-(cues$dist/tau_true)^2)  # Probability each cue is detected
cues$detected <- rbinom(nrow(cues),1,cues$p) # binary variable: was cue actually detected?
# Isolate first detected cue for each bird
dat <- subset(cues,detected == 1)
dat <- dat[!duplicated(dat$bird_id),]
# Transcription: when distance is fixed
tint <- c(3,5,10)
rint <- c(0.5,1,Inf)
dat$tint <- cut(dat$time,c(0,tint))
dat$rint <- cut(dat$dist,c(0,rint))
Y = table(dat$rint,dat$tint)
# Change to vector format (so dcat() can work in JAGS)
Y_vec <- reshape2::melt(Y) %>%
rename(rint = Var1, tint = Var2, Y = value)
Y_rint_numeric <- factor(Y_vec$rint) %>% as.numeric()
Y_tint_numeric <- factor(Y_vec$tint) %>% as.numeric()
Y_vectorized <- Y_vec$Y
Y_vectorized[1] <- Y_vectorized[1] - 20
# ------------------------------------
# PART 2: FIT MODELS WITH STANDARD QPAD
# ------------------------------------
# Distance model
Y_distance = matrix(rowSums(Y),1)
D_distance = matrix(rint,1)
# Removal model
Y_removal = matrix(colSums(Y),1)
D_removal = matrix(tint,1)
fit.q <- cmulti.fit(Y_distance,D_distance, type = "dis")
tau_MLE = exp(fit.q$coefficients)
fit.p <- cmulti.fit(Y_removal,D_removal, type = "rem")
phi_MLE = exp(fit.p$coefficients)
# Estimate density
A_hat = pi*tau_MLE^2
p_hat = 1-exp(-max(tint)*phi_MLE)
Density_MLE <- sum(Y)/(A_hat*p_hat)
tau_MLE
phi_MLE
# ------------------------------------
# PART 3: GENERATE 'AUGMENTED' DATA
# ------------------------------------
# Plausible initial values
phi_init = 0.2
tau_init = 1.2
# Data augmentation
Nsim = 1000 # Number of sim_birds to place on landscape (size of augmented dataset)
dim = 6 # landscape size (dim x dim landscape)
sim_birds <- data.frame(bird_id = 1:Nsim,
x = runif(Nsim,-dim/2,dim/2),
y = runif(Nsim,-dim/2,dim/2))
# Random distances to observer
sim_birds$dist <- sqrt(sim_birds$x^2 + sim_birds$y^2)
sim_birds$rint <- cut(sim_birds$dist,c(0,rint))
# Sort simulated sim_birds by distance
sim_birds <- sim_birds %>% arrange(dist)
# Group simulated birds into distance bins
sim_birds$rint <- cut(sim_birds$dist,c(0,rint))
sim_birds$rint_num <- sim_birds$rint %>% factor() %>% as.numeric()
# For each distance bin, store first and last bird in that bin
r_from <- r_to <- rint*NA
for (i in 1:length(rint)){
r_from[i] <- min(which(sim_birds$rint_num == i))
r_to[i] <- max(which(sim_birds$rint_num == i))
}
jags_data <- list(
pi = pi,
N_det = sum(Y),
Y_vectorized = Y_vectorized,
# Time bin information
tint = tint,
ntint = length(tint),
tint_duration = diff(c(0,tint)),
# Distance bin information
nrint = length(rint),
# Data augmentation
Nsim = nrow(sim_birds),
sim_dist = sim_birds$dist,
# Distance that each simulated bird belongs to
r_from = r_from,
r_to = r_to,
# To vectorize
n_bins_vectorized = length(Y_rint_numeric),
Y_rint_numeric = Y_rint_numeric,
Y_tint_numeric = Y_tint_numeric
)
# Fit model
inits <- function()list(phi = phi_true,
tau = tau_true)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau"),
inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix"),
inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
out$sims.list$Ysim_matrix %>% dim()
out$sims.list$Ysim_matrix[1,,]
out$sims.list$Ysim_matrix[2,,]
Y
sink("QPAD_corrected_vectorized.jags")
cat("
model {
# ------------------------------
# Priors
# ------------------------------
dummy ~ dunif(0,1)
#phi ~ dunif(0,2)
#tau ~ dunif(0,3)
phi <- 0.5
tau <- 1
# ------------------------------
# Simulation
# ------------------------------
# For each simulated bird, probability it has generated at least one detectable cue by end of time interval
for (i in 1:Nsim){
# Simulate cueing for each bird in each time interval
for (j in 1:ntint){
# Expected number of cues produced up to end of interval
lambda[i,j] <- phi*tint[j]*exp(-(sim_dist[i]/tau)^2)
# Probability bird produces at least one detectable cue by end of interval
p[i,j] <- 1 - exp(-lambda[i,j])
}
}
# Sum up number of detected birds in each time and distance bin (this is sort of equivalent to the CDF)
for (i in 1:nrint){
for (j in 1:ntint){
Dsim_matrix[i,j] <- sum(p[r_from[i]:r_to[i],j])
}
}
# Difference to calculate cell probabilities
for (i in 1:nrint){
Ysim_matrix[i,1] <- Dsim_matrix[i,1]
for (j in 2:ntint){
Ysim_matrix[i,j] <- Dsim_matrix[i,j] - sum(Dsim_matrix[i,(j-1)])
}
}
# Place counts in correct vectorized bins
for (i in 1:n_bins_vectorized){
Ysim_vectorized[i] <- Ysim_matrix[Y_rint_numeric[i],Y_tint_numeric[i]]
}
# -----------------------------------------------------
# Use relative proportions for detectability modeling
# -----------------------------------------------------
#Y_vectorized[1:n_bins_vectorized] ~ dmulti(Ysim_vectorized[],N_det)
}
",fill = TRUE)
sink()
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix"),
inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix"),
#inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
out
out$sims.list$Ysim_matrix[1,,]
out$sims.list$Ysim_matrix[2,,]
Y
Y/sum(Y)
out$sims.list$Ysim_matrix[1,,]/sum(out$sims.list$Ysim_matrix[1,,])
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix","p"),
#inits = inits,
n.chains = 3,
n.thin = 5,
n.iter = 5000,
n.burnin = 2000,
parallel = TRUE)
out$sims.list$p[1,,]
round(9.931086e-01,2)
round(1.019358e-01,2)
birds$dist[333,]
birds$dist[333]
# Plausible initial values
phi_init = 0.2
tau_init = 1.2
# Data augmentation
Nsim = 10000 # Number of sim_birds to place on landscape (size of augmented dataset)
dim = 6 # landscape size (dim x dim landscape)
sim_birds <- data.frame(bird_id = 1:Nsim,
x = runif(Nsim,-dim/2,dim/2),
y = runif(Nsim,-dim/2,dim/2))
# Random distances to observer
sim_birds$dist <- sqrt(sim_birds$x^2 + sim_birds$y^2)
sim_birds$rint <- cut(sim_birds$dist,c(0,rint))
# Sort simulated sim_birds by distance
sim_birds <- sim_birds %>% arrange(dist)
# Group simulated birds into distance bins
sim_birds$rint <- cut(sim_birds$dist,c(0,rint))
sim_birds$rint_num <- sim_birds$rint %>% factor() %>% as.numeric()
# For each distance bin, store first and last bird in that bin
r_from <- r_to <- rint*NA
for (i in 1:length(rint)){
r_from[i] <- min(which(sim_birds$rint_num == i))
r_to[i] <- max(which(sim_birds$rint_num == i))
}
jags_data <- list(
pi = pi,
N_det = sum(Y),
Y_vectorized = Y_vectorized,
# Time bin information
tint = tint,
ntint = length(tint),
tint_duration = diff(c(0,tint)),
# Distance bin information
nrint = length(rint),
# Data augmentation
Nsim = nrow(sim_birds),
sim_dist = sim_birds$dist,
# Distance that each simulated bird belongs to
r_from = r_from,
r_to = r_to,
# To vectorize
n_bins_vectorized = length(Y_rint_numeric),
Y_rint_numeric = Y_rint_numeric,
Y_tint_numeric = Y_tint_numeric
)
# Fit model
inits <- function()list(phi = phi_true,
tau = tau_true)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix","p"),
#inits = inits,
n.chains = 1,
n.thin = 1,
n.iter = 2,
n.burnin = 1,
parallel = TRUE)
out$sims.list$p[1,,]
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix","p","dummy"),
#inits = inits,
n.chains = 1,
n.thin = 1,
n.iter = 2,
n.burnin = 1,
parallel = TRUE,
codaOnly=c("phi","tau","Ysim_matrix","p"))
out$sims.list$p[1,,]
Y/sum(Y)
out$sims.list$Ysim_matrix[1,,]/sum(out$sims.list$Ysim_matrix[1,,])
out$sims.list$Ysim_matrix[1,1,]
out$sims.list$Ysim_matrix[1,1,]/sum(out$sims.list$Ysim_matrix[1,,])
out$sims.list$Ysim_matrix[1,1,]/sum(out$sims.list$Ysim_matrix[1,1,])
Y[1,]/sum(Y[1,])
Y[2,]/sum(Y[2,])
out$sims.list$Ysim_matrix[1,2,]/sum(out$sims.list$Ysim_matrix[1,2,])
Y[3,]/sum(Y[3,])
out$sims.list$Ysim_matrix[1,3,]/sum(out$sims.list$Ysim_matrix[1,3,])
# Plausible initial values
phi_init = 0.2
tau_init = 1.2
# Data augmentation
Nsim = 50000 # Number of sim_birds to place on landscape (size of augmented dataset)
dim = 6 # landscape size (dim x dim landscape)
sim_birds <- data.frame(bird_id = 1:Nsim,
x = runif(Nsim,-dim/2,dim/2),
y = runif(Nsim,-dim/2,dim/2))
# Random distances to observer
sim_birds$dist <- sqrt(sim_birds$x^2 + sim_birds$y^2)
sim_birds$rint <- cut(sim_birds$dist,c(0,rint))
# Sort simulated sim_birds by distance
sim_birds <- sim_birds %>% arrange(dist)
# Group simulated birds into distance bins
sim_birds$rint <- cut(sim_birds$dist,c(0,rint))
sim_birds$rint_num <- sim_birds$rint %>% factor() %>% as.numeric()
# For each distance bin, store first and last bird in that bin
r_from <- r_to <- rint*NA
for (i in 1:length(rint)){
r_from[i] <- min(which(sim_birds$rint_num == i))
r_to[i] <- max(which(sim_birds$rint_num == i))
}
jags_data <- list(
pi = pi,
N_det = sum(Y),
Y_vectorized = Y_vectorized,
# Time bin information
tint = tint,
ntint = length(tint),
tint_duration = diff(c(0,tint)),
# Distance bin information
nrint = length(rint),
# Data augmentation
Nsim = nrow(sim_birds),
sim_dist = sim_birds$dist,
# Distance that each simulated bird belongs to
r_from = r_from,
r_to = r_to,
# To vectorize
n_bins_vectorized = length(Y_rint_numeric),
Y_rint_numeric = Y_rint_numeric,
Y_tint_numeric = Y_tint_numeric
)
# Fit model
inits <- function()list(phi = phi_true,
tau = tau_true)
# Using initial values
out <- jags(data = jags_data,
model.file =  "QPAD_corrected_vectorized.jags",
parameters.to.save = c("phi","tau","Ysim_matrix","p","dummy"),
#inits = inits,
n.chains = 1,
n.thin = 1,
n.iter = 2,
n.burnin = 1,
parallel = TRUE,
codaOnly=c("phi","tau","Ysim_matrix","p"))
out$sims.list$p[1,,]
out$sims.list$Ysim_matrix[1,,]
out$sims.list$Ysim_matrix[2,,]
Y/sum(Y)
out$sims.list$Ysim_matrix[1,,]/sum(out$sims.list$Ysim_matrix[1,,])
Y[1,]/sum(Y[1,])
out$sims.list$Ysim_matrix[1,1,]/sum(out$sims.list$Ysim_matrix[1,1,])
Y[2,]/sum(Y[2,])
out$sims.list$Ysim_matrix[1,2,]/sum(out$sims.list$Ysim_matrix[1,2,])
Y[3,]/sum(Y[3,])
out$sims.list$Ysim_matrix[1,3,]/sum(out$sims.list$Ysim_matrix[1,3,])
