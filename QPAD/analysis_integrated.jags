
    model {
    
    # ------------------------------
    # Priors
    # ------------------------------
    
    # Relatively wide, flat priors
    phi ~ dunif(0,5)
    tau ~ dunif(0,5)
    
    # ------------------------------
    # Numerical integration
    # ------------------------------
    
    # Calculate CDF across distance and time bins
    for (j in 1:ntint){
      for (i in 1:(nbins-1)){
        CDF[i,j] = ((pi * bins[i+1]^2) - (pi*bins[i]^2)) * (1-exp(-phi*tint[j]*exp(-midpoints[i]^2/tau^2)))
      }
      
      # Sum within each distance bin to calculate binned CDF
      for (i in 1:nrint){
        CDF_binned[i,j] <- sum(CDF[1:rint_indices[i+1],j])
      }
    }
    
    # --------------------------------------------------------
    # Difference CDF to calculate multinomial cell probabilities
    # --------------------------------------------------------
    
    tmp1[1,1:ntint] <- CDF_binned[1,1:ntint]
    for (i in 2:nrint){
      tmp1[i,1:ntint] <- CDF_binned[i,1:ntint] - CDF_binned[i-1,1:ntint]
    }
    
    p_matrix[1:nrint,1] <- tmp1[1:nrint,1]
    for (j in 2:ntint){
      p_matrix[1:nrint,j] <- tmp1[1:nrint,j] - tmp1[1:nrint,j-1]
    }
    
    # --------------------------------------------------------
    # Place  in vectorized cells for use with dmulti()
    # --------------------------------------------------------
    
    for (i in 1:n_bins_vectorized){
        p_vectorized[i] <- p_matrix[Y_rint_numeric[i],Y_tint_numeric[i]]
    }
    
    # -----------------------------------------------------
    # Use relative proportions for detectability modeling
    # Note that JAGS automatically normalizes p_vectorized (p_vectorized/sum(p_vectorized)) so that probabilities sum to 1
    # -----------------------------------------------------
    
    # Observed counts in each distance/time bin
    Y_vectorized[1:n_bins_vectorized] ~ dmulti(p_vectorized[],Total_detected)
    
    # -----------------------------------------------------
    # Density
    # -----------------------------------------------------

    C <- sum(p_vectorized[])/(pi*pow(bins[nbins],2))
    Y_corrected <- sum(Y_vectorized[])/C
    Density <- Y_corrected/(pi*pow(bins[nbins],2))
    
  }
    

