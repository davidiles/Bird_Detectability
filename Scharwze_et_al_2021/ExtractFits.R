library(plyr)
library(dplyr)
library(tidyr)
library(rstan)
library(mcmcse)

# Load data
dat <- readRDS("gcspdata.rds")

# Different Model Fits
model_vec <- c(State = "gcsp_state",
               Event = "gcsp_event",
               Comb_orig = "gcspfit")
ms <- length(model_vec)

# Instantiate storage objects
fit.df <- summaries <- ESS <- mESS <- abundance <- density <- 
  pdet <- pavl <- ppcpt <- pst <- pev <- ll <- vector('list', ms) %>% setNames(names(model_vec))

# Loop through model fit and extract data
for(m_indx in 1:ms){
  
  # Load model fit
  fit <- readRDS(paste0(model_vec[m_indx],".rds"))

  # Useful code snippet sometimes: vector of unique model parameters without the square brackets generated by Stan
  # sub("\\[.*", "", fit@model_pars)
  
  # Vector of parameters to extract
  mpars <- c(recordlist(fit@model_name, surv_level=F), "mean_pavl", "mean_pst", "mean_pev", "mean_pp")
  if(fit@model_name == "Survey") mpars <- mpars[-which(mpars=="mean_pev")] # Remove event pcpt from list for state models
  if(fit@model_name == "Event")  mpars <- mpars[-which(mpars=="mean_pst")] # Remove state pcpt from list for event models
  
  maxdist <- dat$maxdist    # Maximum distance in analysis
  
  # Posterior samples
  fit.df[[m_indx]]    <- as.data.frame(fit, pars=mpars) %>% mutate(model = model_vec[m_indx])
  
  # Compile tabular summaries from summary(stanfit)$summary output
  summaries[[m_indx]] <- fit %>% summary(pars=mpars) %>% .[["summary"]] %>% 
    data.frame(model=model_vec[m_indx], stringsAsFactors=F) %>% mutate(parameter=rownames(.))
  
  # Compile number of effective samples (independent and multivariate versions... I prefer mESS, myself)
  # ESS[[m_indx]]       <- as.data.frame(fit, pars=mpars) %>% mcmcse::ess() %>% t() %>% 
  #   as.data.frame() %>% mutate(model=model_vec[m_indx])
  # # Note: int_vec, mixing, and global_p are duplicate names and cause perfect collinearity
  # mESS[[m_indx]]      <- as.data.frame(fit, pars=mpars[!grepl("mean", mpars)][-which(
  #   mpars %in% c("int_vec", "mixing", "global_p")
  # )]) %>% mcmcse::multiESS()
  
  # For each posterior draw:
  
  # Extract sum(totN)... total population over all sites
  #   The '2' converts from males only to all birds
  abundance[[m_indx]] <- 2 * rowSums(as.data.frame(fit, pars="totN"))
  # Density = Abundance/#Surveys divided by pi*maxdist^2 converted from sq.m. to hectares
  density[[m_indx]]   <- abundance[[m_indx]] / (pi*maxdist^2*length(grep("totN", names(fit))) ) * 10^4
  # Abundance-weighted average posterior pdet (i.e. averaged across birds, not sites), aka proportion of all birds detected
  pdet[[m_indx]]      <- as.data.frame(fit, pars="global_p")
  # Abundance-weighted average p_avl
  pavl[[m_indx]]      <- as.data.frame(fit, pars="mean_pavl")
  # Abundance-weighted average p_pcpt = Pr(detection | available, r) averaged over all distances and surveys
  ppcpt[[m_indx]]     <- rstan::extract(fit, pars="mean_pp")
  # Abundance-weighted average p_pst = IJ perceptibility averaged over all distances and surveys
  if(!fit@model_name == "Event") pst[[m_indx]]  <- rstan::extract(fit, pars="mean_pst")
  # Abundance-weighted average p_pev = PP perceptibility averaged over all distances and surveys
  if(!fit@model_name == "Survey") pev[[m_indx]] <- rstan::extract(fit, pars="mean_pev")

  ll[[m_indx]] <- rstan::extract(fit, pars="log_lik")[[1]] %>% rowSums()
}

fit.df    <- bind_rows(fit.df)
summaries <- bind_rows(summaries)
ESS       <- bind_rows(ESS)

outputs <- list(
  fit.df    = fit.df,
  summaries = summaries,
  ESS       = ESS,
  mESS      = mESS,
  abundance = abundance,
  density   = density,
  pdet      = pdet,
  pavl      = pavl,
  ppcpt     = ppcpt,
  ll        = ll
)

saveRDS(outputs, "Outputs.rds")
